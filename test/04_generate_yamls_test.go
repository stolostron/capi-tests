package test

import (
	"os"
	"path/filepath"
	"testing"
)

// infrastructureGenerationSucceeded tracks whether TestInfrastructure_GenerateResources completed successfully.
// When false, dependent verification tests will skip to avoid confusing cascading failures.
var infrastructureGenerationSucceeded bool

// TestInfrastructure_GenerateResources tests generating ARO infrastructure resources
func TestInfrastructure_GenerateResources(t *testing.T) {

	config := NewTestConfig()

	if !DirExists(config.RepoDir) {
		t.Skipf("Repository not cloned yet at %s", config.RepoDir)
	}

	// Validate domain prefix length before attempting YAML generation
	// The domain prefix is derived from USER and DEPLOYMENT_ENV and must not exceed 15 characters
	if err := ValidateDomainPrefix(config.CAPZUser, config.Environment); err != nil {
		t.Fatalf("Domain prefix validation failed: %v", err)
	}
	t.Logf("Domain prefix validation passed: '%s' (%d chars)",
		GetDomainPrefix(config.CAPZUser, config.Environment),
		len(GetDomainPrefix(config.CAPZUser, config.Environment)))

	genScriptPath := filepath.Join(config.RepoDir, config.GenScriptPath)
	if !FileExists(genScriptPath) {
		t.Errorf("Generation script not found: %s", genScriptPath)
		return
	}

	// Output directory for generated resources
	outputDir := filepath.Join(config.RepoDir, config.GetOutputDirName())

	t.Logf("Generating infrastructure resources for cluster '%s' (env: %s)", config.WorkloadClusterName, config.Environment)

	// Set environment variables for the generation script
	SetEnvVar(t, "DEPLOYMENT_ENV", config.Environment)
	SetEnvVar(t, "USER", config.CAPZUser)
	SetEnvVar(t, "WORKLOAD_CLUSTER_NAME", config.WorkloadClusterName)
	SetEnvVar(t, "REGION", config.Region)
	SetEnvVar(t, "CS_CLUSTER_NAME", config.ClusterNamePrefix)
	SetEnvVar(t, "OPENSHIFT_VERSION", config.OpenShiftVersion)

	if config.AzureSubscriptionName != "" {
		SetEnvVar(t, "AZURE_SUBSCRIPTION_NAME", config.AzureSubscriptionName)
	}

	// Change to repository directory for script execution
	originalDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get current directory: %v", err)
	}
	defer os.Chdir(originalDir)

	if err := os.Chdir(config.RepoDir); err != nil {
		t.Fatalf("Failed to change to repository directory: %v", err)
	}

	// Run the generation script
	PrintToTTY("\n=== Generating infrastructure resources ===\n")
	PrintToTTY("Running infrastructure generation script: %s %s\n", genScriptPath, config.GetOutputDirName())
	t.Log("Running infrastructure generation script...")
	output, err := RunCommand(t, "bash", genScriptPath, config.GetOutputDirName())
	if err != nil {
		// On error, show output for debugging (may contain sensitive info, but needed for troubleshooting)
		t.Errorf("Failed to generate infrastructure resources: %v\nOutput: %s", err, output)
		return
	}

	// Don't log full output as it may contain Azure resource IDs and other sensitive information
	PrintToTTY("✅ Infrastructure generation completed successfully\n")
	t.Log("Infrastructure generation completed successfully")

	// Verify generated files exist
	if !DirExists(outputDir) {
		t.Errorf("Output directory not created: %s", outputDir)
		return
	}

	PrintToTTY("Output directory created: %s\n", outputDir)
	t.Logf("Output directory created: %s", outputDir)

	// Log paths of all generated files
	expectedFiles := []string{
		"credentials.yaml",
		"is.yaml",
		"aro.yaml",
	}
	for _, file := range expectedFiles {
		filePath := filepath.Join(outputDir, file)
		if FileExists(filePath) {
			info, err := os.Stat(filePath)
			if err != nil {
				PrintToTTY("  ⚠️  Generated file: %s (unable to stat: %v)\n", filePath, err)
				t.Logf("Generated file: %s (unable to stat: %v)", filePath, err)
			} else {
				PrintToTTY("  ✅ Generated file: %s (%d bytes)\n", filePath, info.Size())
				t.Logf("Generated file: %s (size: %d bytes)", filePath, info.Size())
			}
		} else {
			PrintToTTY("  ❌ Expected generated file not found: %s\n", filePath)
			t.Errorf("Expected generated file not found: %s", filePath)
		}
	}
	PrintToTTY("\n")

	// Mark generation as successful only if no errors occurred
	if !t.Failed() {
		infrastructureGenerationSucceeded = true
	}
}

// TestInfrastructure_VerifyCredentialsYAML verifies credentials.yaml exists and is valid
func TestInfrastructure_VerifyCredentialsYAML(t *testing.T) {
	if !infrastructureGenerationSucceeded {
		t.Skip("Skipping: TestInfrastructure_GenerateResources did not succeed")
	}

	t.Log("Verifying credentials.yaml")

	config := NewTestConfig()
	outputDir := filepath.Join(config.RepoDir, config.GetOutputDirName())

	if !DirExists(outputDir) {
		t.Skipf("Output directory does not exist: %s", outputDir)
	}

	filePath := filepath.Join(outputDir, "credentials.yaml")
	if !FileExists(filePath) {
		t.Errorf("credentials.yaml not found at %s.\n\n"+
			"This file should be generated by TestInfrastructure_GenerateResources.\n\n"+
			"To regenerate:\n"+
			"  go test -v ./test -run TestInfrastructure_GenerateResources\n\n"+
			"Or manually run the generation script:\n"+
			"  cd %s && bash %s %s",
			filePath, config.RepoDir, config.GenScriptPath, config.GetOutputDirName())
		return
	}

	// Validate YAML syntax and structure
	if err := ValidateYAMLFile(filePath); err != nil {
		t.Errorf("credentials.yaml validation failed: %v", err)
		return
	}

	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("Failed to stat credentials.yaml: %v", err)
	}

	t.Logf("credentials.yaml is valid YAML (size: %d bytes)", info.Size())
}

// TestInfrastructure_VerifyInfrastructureSecretsYAML verifies is.yaml exists and is valid
func TestInfrastructure_VerifyInfrastructureSecretsYAML(t *testing.T) {
	if !infrastructureGenerationSucceeded {
		t.Skip("Skipping: TestInfrastructure_GenerateResources did not succeed")
	}

	t.Log("Verifying is.yaml (infrastructure secrets)")

	config := NewTestConfig()
	outputDir := filepath.Join(config.RepoDir, config.GetOutputDirName())

	if !DirExists(outputDir) {
		t.Skipf("Output directory does not exist: %s", outputDir)
	}

	filePath := filepath.Join(outputDir, "is.yaml")
	if !FileExists(filePath) {
		t.Errorf("is.yaml (infrastructure secrets) not found at %s.\n\n"+
			"This file should be generated by TestInfrastructure_GenerateResources.\n\n"+
			"To regenerate:\n"+
			"  go test -v ./test -run TestInfrastructure_GenerateResources\n\n"+
			"Or manually run the generation script:\n"+
			"  cd %s && bash %s %s",
			filePath, config.RepoDir, config.GenScriptPath, config.GetOutputDirName())
		return
	}

	// Validate YAML syntax and structure
	if err := ValidateYAMLFile(filePath); err != nil {
		t.Errorf("is.yaml validation failed: %v", err)
		return
	}

	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("Failed to stat is.yaml: %v", err)
	}

	t.Logf("is.yaml is valid YAML (size: %d bytes)", info.Size())
}

// TestInfrastructure_VerifyAROClusterYAML verifies aro.yaml exists and is valid
func TestInfrastructure_VerifyAROClusterYAML(t *testing.T) {
	if !infrastructureGenerationSucceeded {
		t.Skip("Skipping: TestInfrastructure_GenerateResources did not succeed")
	}

	t.Log("Verifying aro.yaml (ARO cluster configuration)")

	config := NewTestConfig()
	outputDir := filepath.Join(config.RepoDir, config.GetOutputDirName())

	if !DirExists(outputDir) {
		t.Skipf("Output directory does not exist: %s", outputDir)
	}

	filePath := filepath.Join(outputDir, "aro.yaml")
	if !FileExists(filePath) {
		t.Errorf("aro.yaml (ARO cluster configuration) not found at %s.\n\n"+
			"This file should be generated by TestInfrastructure_GenerateResources.\n\n"+
			"To regenerate:\n"+
			"  go test -v ./test -run TestInfrastructure_GenerateResources\n\n"+
			"Or manually run the generation script:\n"+
			"  cd %s && bash %s %s",
			filePath, config.RepoDir, config.GenScriptPath, config.GetOutputDirName())
		return
	}

	// Validate YAML syntax and structure
	if err := ValidateYAMLFile(filePath); err != nil {
		t.Errorf("aro.yaml validation failed: %v", err)
		return
	}

	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("Failed to stat aro.yaml: %v", err)
	}

	t.Logf("aro.yaml is valid YAML (size: %d bytes)", info.Size())
}

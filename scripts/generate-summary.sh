#!/usr/bin/env bash
#
# generate-summary.sh - Generate a summary report from JUnit XML test results
#
# This script parses JUnit XML files generated by gotestsum and produces
# a human-readable summary of test results across all test phases.
#
# Usage:
#   ./scripts/generate-summary.sh <results-directory>
#
# Example:
#   ./scripts/generate-summary.sh results/20260106_212030
#
# Output:
#   - Prints summary to stdout (with colors)
#   - Creates summary.txt in the results directory (plain text)
#
# The summary includes:
#   - Per-test results (PASS/FAIL/SKIP) with timing
#   - Per-phase totals
#   - Overall totals across all phases
#   - Links to controller logs (CAPI, CAPZ, ASO) if available
#   - Link to terminal output log (complete test run output) if available

set -eo pipefail

# Colors for terminal output (disabled if not a terminal or NO_COLOR is set)
if [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]; then
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    NC='\033[0m' # No Color
else
    GREEN=''
    RED=''
    YELLOW=''
    NC=''
fi

# Function to print usage
usage() {
    echo "Usage: $0 <results-directory>"
    echo ""
    echo "Generate a summary report from JUnit XML test results."
    echo ""
    echo "Arguments:"
    echo "  results-directory    Directory containing JUnit XML files"
    echo ""
    echo "Example:"
    echo "  $0 results/20260106_212030"
    exit 1
}

# Validate arguments
if [[ $# -lt 1 ]]; then
    usage
fi

RESULTS_DIR="$1"

if [[ ! -d "$RESULTS_DIR" ]]; then
    echo "Error: Directory '$RESULTS_DIR' does not exist" >&2
    exit 1
fi

# Check for xmllint availability
if ! command -v xmllint &> /dev/null; then
    echo "Error: xmllint is required but not installed" >&2
    echo "Install with: sudo apt-get install libxml2-utils (Debian/Ubuntu)" >&2
    echo "           or: sudo dnf install libxml2 (Fedora)" >&2
    exit 1
fi

# Phase names mapping (filename prefix to display name)
# Using a function instead of associative array for bash 3.2 compatibility (macOS)
get_phase_name() {
    case "$1" in
        "junit-check-dep") echo "Check Dependencies" ;;
        "junit-setup") echo "Repository Setup" ;;
        "junit-cluster") echo "Cluster Deployment" ;;
        "junit-generate-yamls") echo "YAML Generation" ;;
        "junit-deploy-crs") echo "CR Deployment" ;;
        "junit-verify") echo "Cluster Verification" ;;
        "junit-delete") echo "Cluster Deletion" ;;
        *) echo "$1" ;;
    esac
}

# Phase order for consistent output
PHASE_ORDER=(
    "junit-check-dep"
    "junit-setup"
    "junit-cluster"
    "junit-generate-yamls"
    "junit-deploy-crs"
    "junit-verify"
    "junit-delete"
)

# Global counters (will be modified by functions)
TOTAL_TESTS=0
TOTAL_PASSED=0
TOTAL_FAILED=0
TOTAL_SKIPPED=0
TOTAL_TIME=0

# Function to format duration
format_duration() {
    local seconds="$1"

    # Handle floating point by extracting integer part
    local int_seconds
    int_seconds=$(echo "$seconds" | cut -d. -f1)
    int_seconds=${int_seconds:-0}

    if [[ $int_seconds -lt 60 ]]; then
        printf "%.2fs" "$seconds"
    elif [[ $int_seconds -lt 3600 ]]; then
        local mins=$((int_seconds / 60))
        local secs=$((int_seconds % 60))
        printf "%dm%02ds" "$mins" "$secs"
    else
        local hours=$((int_seconds / 3600))
        local mins=$(((int_seconds % 3600) / 60))
        local secs=$((int_seconds % 60))
        printf "%dh%02dm%02ds" "$hours" "$mins" "$secs"
    fi
}

# Function to parse a single JUnit XML file and print results
# Arguments: $1 = file path, $2 = phase_key, $3 = use_colors (true/false)
parse_junit_file() {
    local file="$1"
    local phase_key="$2"
    local use_colors="${3:-true}"
    local phase_name
    phase_name=$(get_phase_name "$phase_key")

    if [[ ! -f "$file" ]]; then
        return
    fi

    # Set colors based on use_colors flag
    local c_green c_red c_yellow c_nc
    if [[ "$use_colors" == "true" ]]; then
        c_green="${GREEN}"
        c_red="${RED}"
        c_yellow="${YELLOW}"
        c_nc="${NC}"
    else
        c_green=""
        c_red=""
        c_yellow=""
        c_nc=""
    fi

    # Extract testsuite attributes
    local tests failures errors time
    tests=$(xmllint --xpath 'string(//testsuites/@tests)' "$file" 2>/dev/null || echo "0")
    failures=$(xmllint --xpath 'string(//testsuites/@failures)' "$file" 2>/dev/null || echo "0")
    errors=$(xmllint --xpath 'string(//testsuites/@errors)' "$file" 2>/dev/null || echo "0")
    time=$(xmllint --xpath 'string(//testsuites/@time)' "$file" 2>/dev/null || echo "0")

    # Handle empty values
    tests=${tests:-0}
    failures=${failures:-0}
    errors=${errors:-0}
    time=${time:-0}

    # Calculate passed and skipped
    local total_failures=$((failures + errors))

    # Count skipped tests by looking for <skipped> elements
    local skipped
    skipped=$(xmllint --xpath 'count(//testcase/skipped)' "$file" 2>/dev/null || echo "0")
    skipped=${skipped%.*}  # Remove decimal part
    skipped=${skipped:-0}

    local passed=$((tests - total_failures - skipped))

    # Update global totals
    TOTAL_TESTS=$((TOTAL_TESTS + tests))
    TOTAL_PASSED=$((TOTAL_PASSED + passed))
    TOTAL_FAILED=$((TOTAL_FAILED + total_failures))
    TOTAL_SKIPPED=$((TOTAL_SKIPPED + skipped))
    TOTAL_TIME=$(echo "$TOTAL_TIME + $time" | bc)

    # Print phase header
    echo ""
    echo "=== $phase_name ==="
    echo ""

    # Get all testcase names and their status
    local testcase_count
    testcase_count=$(xmllint --xpath 'count(//testcase)' "$file" 2>/dev/null || echo "0")
    testcase_count=${testcase_count%.*}

    local i
    for ((i=1; i<=testcase_count; i++)); do
        local name tc_time status status_color
        name=$(xmllint --xpath "string(//testcase[$i]/@name)" "$file" 2>/dev/null || echo "unknown")
        tc_time=$(xmllint --xpath "string(//testcase[$i]/@time)" "$file" 2>/dev/null || echo "0")

        # Check for failure or skip
        local has_failure has_skip has_error
        has_failure=$(xmllint --xpath "count(//testcase[$i]/failure)" "$file" 2>/dev/null || echo "0")
        has_skip=$(xmllint --xpath "count(//testcase[$i]/skipped)" "$file" 2>/dev/null || echo "0")
        has_error=$(xmllint --xpath "count(//testcase[$i]/error)" "$file" 2>/dev/null || echo "0")

        if [[ "${has_failure%.*}" -gt 0 ]] || [[ "${has_error%.*}" -gt 0 ]]; then
            status="FAIL"
            status_color="${c_red}"
        elif [[ "${has_skip%.*}" -gt 0 ]]; then
            status="SKIP"
            status_color="${c_yellow}"
        else
            status="PASS"
            status_color="${c_green}"
        fi

        # Format output - align columns
        printf "${status_color}%-4s${c_nc} test.%-60s (%.2fs)\n" "$status" "$name" "$tc_time"
    done

    # Print phase summary
    local formatted_time
    formatted_time=$(format_duration "$time")
    echo ""
    echo "DONE $tests tests in $formatted_time"
}

# Function to list available controller logs in the results directory
# Arguments: $1 = use_colors (true/false)
list_controller_logs() {
    local use_colors="${1:-true}"

    # Set colors based on use_colors flag
    local c_green c_nc
    if [[ "$use_colors" == "true" ]]; then
        c_green="${GREEN}"
        c_nc="${NC}"
    else
        c_green=""
        c_nc=""
    fi

    # Controller log file patterns
    local controller_patterns=("capi-*.log" "capz-*.log" "aso-*.log")
    local found_logs=()

    # Find controller log files
    for pattern in "${controller_patterns[@]}"; do
        while IFS= read -r -d '' logfile; do
            found_logs+=("$logfile")
        done < <(find "$RESULTS_DIR" -maxdepth 1 -name "$pattern" -type f -print0 2>/dev/null | sort -z)
    done

    # Only print section if logs were found
    if [[ ${#found_logs[@]} -gt 0 ]]; then
        echo ""
        echo "========================================"
        echo "         CONTROLLER LOGS"
        echo "========================================"
        echo ""
        echo "The following controller logs are available for troubleshooting:"
        echo ""

        local filename controller_name
        for logfile in "${found_logs[@]}"; do
            filename=$(basename "$logfile")
            # Extract controller name from filename (e.g., "capi" from "capi-20260106_212030.log")
            controller_name=$(echo "$filename" | cut -d'-' -f1 | tr '[:lower:]' '[:upper:]')
            printf "${c_green}  %s${c_nc}: %s\n" "$controller_name" "$logfile"
        done

        echo ""
    fi
}

# Function to list terminal output file if available
# Arguments: $1 = use_colors (true/false)
list_terminal_output() {
    local use_colors="${1:-true}"

    # Set colors based on use_colors flag
    local c_green c_nc
    if [[ "$use_colors" == "true" ]]; then
        c_green="${GREEN}"
        c_nc="${NC}"
    else
        c_green=""
        c_nc=""
    fi

    # Terminal output file (created by make test-all)
    local terminal_output="$RESULTS_DIR/terminal-output.log"

    # Only print section if terminal output file exists
    if [[ -f "$terminal_output" ]]; then
        local file_size
        file_size=$(du -h "$terminal_output" | cut -f1)

        echo ""
        echo "========================================"
        echo "         TERMINAL OUTPUT"
        echo "========================================"
        echo ""
        echo "Complete terminal output from the test run is available:"
        echo ""
        printf "${c_green}  Terminal log${c_nc}: %s (%s)\n" "$terminal_output" "$file_size"
        echo ""
    fi
}

# Function to generate and print the complete summary
# Arguments: $1 = use_colors (true/false)
generate_summary() {
    local use_colors="${1:-true}"

    # Set colors based on use_colors flag
    local c_green c_red c_yellow c_nc
    if [[ "$use_colors" == "true" ]]; then
        c_green="${GREEN}"
        c_red="${RED}"
        c_yellow="${YELLOW}"
        c_nc="${NC}"
    else
        c_green=""
        c_red=""
        c_yellow=""
        c_nc=""
    fi

    # Reset totals
    TOTAL_TESTS=0
    TOTAL_PASSED=0
    TOTAL_FAILED=0
    TOTAL_SKIPPED=0
    TOTAL_TIME=0

    echo "========================================"
    echo "        TEST RESULTS SUMMARY"
    echo "========================================"
    echo ""
    echo "Results directory: $RESULTS_DIR"
    echo "Generated: $(date '+%Y-%m-%d %H:%M:%S')"

    # Process each phase in order
    local phase_key
    for phase_key in "${PHASE_ORDER[@]}"; do
        local file="$RESULTS_DIR/${phase_key}.xml"
        if [[ -f "$file" ]]; then
            parse_junit_file "$file" "$phase_key" "$use_colors"
        fi
    done

    # Print overall summary
    echo ""
    echo "========================================"
    echo "           OVERALL SUMMARY"
    echo "========================================"
    echo ""

    local formatted_total_time
    formatted_total_time=$(format_duration "$TOTAL_TIME")

    printf "Total tests:   %d\n" "$TOTAL_TESTS"
    printf "${c_green}Passed:        %d${c_nc}\n" "$TOTAL_PASSED"
    if [[ $TOTAL_FAILED -gt 0 ]]; then
        printf "${c_red}Failed:        %d${c_nc}\n" "$TOTAL_FAILED"
    else
        printf "Failed:        %d\n" "$TOTAL_FAILED"
    fi
    if [[ $TOTAL_SKIPPED -gt 0 ]]; then
        printf "${c_yellow}Skipped:       %d${c_nc}\n" "$TOTAL_SKIPPED"
    else
        printf "Skipped:       %d\n" "$TOTAL_SKIPPED"
    fi
    printf "Total time:    %s\n" "$formatted_total_time"

    # List controller logs if available
    list_controller_logs "$use_colors"

    # List terminal output file if available
    list_terminal_output "$use_colors"

    if [[ $TOTAL_FAILED -eq 0 ]]; then
        printf "${c_green}All tests passed!${c_nc}\n"
    else
        printf "${c_red}Some tests failed.${c_nc}\n"
    fi
    echo ""
    echo "========================================"
}

# Generate summary with colors for terminal
generate_summary "true"

# Generate plain text summary to file
generate_summary "false" > "$RESULTS_DIR/summary.txt"

echo ""
echo "Summary saved to: $RESULTS_DIR/summary.txt"
